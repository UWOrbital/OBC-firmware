var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"cubesat_alg_dev_env_v2_main/attitude_determination_and_vehicle_est","ref":false,"files":[{"name":"ert_main.c","type":"source","group":"main","path":"C:\\Users\\joshu\\Desktop\\Orbital\\adcs-modelling\\adcs-modelling\\attitude_determination_and_vehi_ert_rtw","tag":"","groupDisplay":"Main file","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: ert_main.c\r\n *\r\n * Code generated for Simulink model 'attitude_determination_and_vehi'.\r\n *\r\n * Model version                  : 3.78\r\n * Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n * C/C++ source code generated on : Mon Jan  1 12:50:14 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-R\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#include <stddef.h>\r\n#include <stdio.h>            /* This example main program uses printf/fflush */\r\n#include \"attitude_determination_and_vehi.h\" /* Model header file */\r\n\r\n/*\r\n * Associating rt_OneStep with a real-time clock or interrupt service routine\r\n * is what makes the generated code \"real-time\".  The function rt_OneStep is\r\n * always associated with the base rate of the model.  Subrates are managed\r\n * by the base rate from inside the generated code.  Enabling/disabling\r\n * interrupts and floating point context switches are target specific.  This\r\n * example code indicates where these should take place relative to executing\r\n * the generated code step function.  Overrun behavior should be tailored to\r\n * your application needs.  This example simply sets an error status in the\r\n * real-time model and returns from rt_OneStep.\r\n */\r\nvoid rt_OneStep(void);\r\nvoid rt_OneStep(void)\r\n{\r\n  static boolean_T OverrunFlag = false;\r\n\r\n  /* Disable interrupts here */\r\n\r\n  /* Check for overrun */\r\n  if (OverrunFlag) {\r\n    rtmSetErrorStatus(rtM, \"Overrun\");\r\n    return;\r\n  }\r\n\r\n  OverrunFlag = true;\r\n\r\n  /* Save FPU context here (if necessary) */\r\n  /* Re-enable timer or interrupt here */\r\n  /* Set model inputs here */\r\n\r\n  /* Step the model */\r\n  attitude_determination_and_vehi_step();\r\n\r\n  /* Get model outputs here */\r\n\r\n  /* Indicate task complete */\r\n  OverrunFlag = false;\r\n\r\n  /* Disable interrupts here */\r\n  /* Restore FPU context here (if necessary) */\r\n  /* Enable interrupts here */\r\n}\r\n\r\n/*\r\n * The example main function illustrates what is required by your\r\n * application code to initialize, execute, and terminate the generated code.\r\n * Attaching rt_OneStep to a real-time clock is target specific. This example\r\n * illustrates how you do this relative to initializing the model.\r\n */\r\nint_T main(int_T argc, const char *argv[])\r\n{\r\n  /* Unused arguments */\r\n  (void)(argc);\r\n  (void)(argv);\r\n\r\n  /* Initialize model */\r\n  attitude_determination_and_vehi_initialize();\r\n\r\n  /* Attach rt_OneStep to a timer or interrupt service routine with\r\n   * period 0.05 seconds (base rate of the model) here.\r\n   * The call syntax for rt_OneStep is\r\n   *\r\n   *  rt_OneStep();\r\n   */\r\n  printf(\"Warning: The simulation will run forever. \"\r\n         \"Generated ERT main won't simulate model step behavior. \"\r\n         \"To change this behavior select the 'MAT-file logging' option.\\n\");\r\n  fflush((NULL));\r\n  while (rtmGetErrorStatus(rtM) == (NULL)) {\r\n    /*  Perform application tasks here */\r\n  }\r\n\r\n  return 0;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"attitude_determination_and_vehi.c","type":"source","group":"model","path":"C:\\Users\\joshu\\Desktop\\Orbital\\adcs-modelling\\adcs-modelling\\attitude_determination_and_vehi_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: attitude_determination_and_vehi.c\r\n *\r\n * Code generated for Simulink model 'attitude_determination_and_vehi'.\r\n *\r\n * Model version                  : 3.78\r\n * Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n * C/C++ source code generated on : Mon Jan  1 12:50:14 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-R\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"attitude_determination_and_vehi.h\"\r\n#include \"rtwtypes.h\"\r\n#include <string.h>\r\n#include <math.h>\r\n\r\n/* Block signals and states (default storage) */\r\nDW rtDW;\r\n\r\n/* External inputs (root inport signals with default storage) */\r\nExtU rtU;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\nExtY rtY;\r\n\r\n/* Real-time model */\r\nstatic RT_MODEL rtM_;\r\nRT_MODEL *const rtM = &rtM_;\r\n\r\n/* Forward declaration for local functions */\r\nstatic void quatrotate(const real_T q[4], real_T v[3]);\r\nstatic void mrdiv(const real_T A[18], const real_T B_0[9], real_T Y[18]);\r\nstatic void quatmultiply(const real_T q[4], const real_T r[4], real_T qout[4]);\r\nstatic real_T norm(const real_T x[4]);\r\n\r\n/* Function for MATLAB Function: '<S1>/MEKF' */\r\nstatic void quatrotate(const real_T q[4], real_T v[3])\r\n{\r\n  real_T y[9];\r\n  real_T y_0[3];\r\n  real_T y_tmp;\r\n  real_T y_tmp_0;\r\n  real_T y_tmp_1;\r\n  real_T y_tmp_2;\r\n  real_T y_tmp_3;\r\n  real_T y_tmp_4;\r\n  int32_T i;\r\n  y_tmp_1 = q[3] * q[3] * 2.0;\r\n  y_tmp_4 = (1.0 - q[2] * q[2] * 2.0) - y_tmp_1;\r\n  y[0] = y_tmp_4;\r\n  y_tmp = q[1] * q[2];\r\n  y_tmp_0 = q[0] * q[3];\r\n  y[3] = (y_tmp + y_tmp_0) * 2.0;\r\n  y_tmp_2 = q[1] * q[3];\r\n  y_tmp_3 = q[0] * q[2];\r\n  y[6] = (y_tmp_2 - y_tmp_3) * 2.0;\r\n  y[1] = (y_tmp - y_tmp_0) * 2.0;\r\n  y[4] = (1.0 - q[1] * q[1] * 2.0) - y_tmp_1;\r\n  y_tmp_1 = q[2] * q[3];\r\n  y_tmp = q[0] * q[1];\r\n  y[7] = (y_tmp_1 + y_tmp) * 2.0;\r\n  y[2] = (y_tmp_2 + y_tmp_3) * 2.0;\r\n  y[5] = (y_tmp_1 - y_tmp) * 2.0;\r\n  y[8] = y_tmp_4;\r\n  y_tmp_1 = v[1];\r\n  y_tmp_4 = v[0];\r\n  y_tmp = v[2];\r\n  for (i = 0; i < 3; i++) {\r\n    y_0[i] = (y[i + 3] * y_tmp_1 + y[i] * y_tmp_4) + y[i + 6] * y_tmp;\r\n  }\r\n\r\n  v[0] = y_0[0];\r\n  v[1] = y_0[1];\r\n  v[2] = y_0[2];\r\n}\r\n\r\n/* Function for MATLAB Function: '<S1>/MEKF' */\r\nstatic void mrdiv(const real_T A[18], const real_T B_0[9], real_T Y[18])\r\n{\r\n  real_T b_A[9];\r\n  real_T a21;\r\n  real_T maxval;\r\n  int32_T r1;\r\n  int32_T r2;\r\n  int32_T r3;\r\n  int32_T rtemp;\r\n  memcpy(&b_A[0], &B_0[0], 9U * sizeof(real_T));\r\n  r1 = 0;\r\n  r2 = 1;\r\n  r3 = 2;\r\n  maxval = fabs(B_0[0]);\r\n  a21 = fabs(B_0[1]);\r\n  if (a21 > maxval) {\r\n    maxval = a21;\r\n    r1 = 1;\r\n    r2 = 0;\r\n  }\r\n\r\n  if (fabs(B_0[2]) > maxval) {\r\n    r1 = 2;\r\n    r2 = 1;\r\n    r3 = 0;\r\n  }\r\n\r\n  b_A[r2] = B_0[r2] / B_0[r1];\r\n  b_A[r3] /= b_A[r1];\r\n  b_A[r2 + 3] -= b_A[r1 + 3] * b_A[r2];\r\n  b_A[r3 + 3] -= b_A[r1 + 3] * b_A[r3];\r\n  b_A[r2 + 6] -= b_A[r1 + 6] * b_A[r2];\r\n  b_A[r3 + 6] -= b_A[r1 + 6] * b_A[r3];\r\n  if (fabs(b_A[r3 + 3]) > fabs(b_A[r2 + 3])) {\r\n    rtemp = r2;\r\n    r2 = r3;\r\n    r3 = rtemp;\r\n  }\r\n\r\n  b_A[r3 + 3] /= b_A[r2 + 3];\r\n  b_A[r3 + 6] -= b_A[r3 + 3] * b_A[r2 + 6];\r\n  for (rtemp = 0; rtemp < 6; rtemp++) {\r\n    int32_T Y_tmp;\r\n    int32_T Y_tmp_0;\r\n    int32_T Y_tmp_1;\r\n    Y_tmp = 6 * r1 + rtemp;\r\n    Y[Y_tmp] = A[rtemp] / b_A[r1];\r\n    Y_tmp_0 = 6 * r2 + rtemp;\r\n    Y[Y_tmp_0] = A[rtemp + 6] - b_A[r1 + 3] * Y[Y_tmp];\r\n    Y_tmp_1 = 6 * r3 + rtemp;\r\n    Y[Y_tmp_1] = A[rtemp + 12] - b_A[r1 + 6] * Y[Y_tmp];\r\n    Y[Y_tmp_0] /= b_A[r2 + 3];\r\n    Y[Y_tmp_1] -= b_A[r2 + 6] * Y[Y_tmp_0];\r\n    Y[Y_tmp_1] /= b_A[r3 + 6];\r\n    Y[Y_tmp_0] -= b_A[r3 + 3] * Y[Y_tmp_1];\r\n    Y[Y_tmp] -= Y[Y_tmp_1] * b_A[r3];\r\n    Y[Y_tmp] -= Y[Y_tmp_0] * b_A[r2];\r\n  }\r\n}\r\n\r\n/* Function for MATLAB Function: '<S1>/MEKF' */\r\nstatic void quatmultiply(const real_T q[4], const real_T r[4], real_T qout[4])\r\n{\r\n  qout[0] = ((q[0] * r[0] - q[1] * r[1]) - q[2] * r[2]) - q[3] * r[3];\r\n  qout[1] = (q[0] * r[1] + r[0] * q[1]) + (q[2] * r[3] - r[2] * q[3]);\r\n  qout[2] = (q[0] * r[2] + r[0] * q[2]) + (r[1] * q[3] - q[1] * r[3]);\r\n  qout[3] = (q[0] * r[3] + r[0] * q[3]) + (q[1] * r[2] - r[1] * q[2]);\r\n}\r\n\r\n/* Function for MATLAB Function: '<S1>/MEKF' */\r\nstatic real_T norm(const real_T x[4])\r\n{\r\n  real_T absxk;\r\n  real_T scale;\r\n  real_T t;\r\n  real_T y;\r\n  scale = 3.3121686421112381E-170;\r\n  absxk = fabs(x[0]);\r\n  if (absxk > 3.3121686421112381E-170) {\r\n    y = 1.0;\r\n    scale = absxk;\r\n  } else {\r\n    t = absxk / 3.3121686421112381E-170;\r\n    y = t * t;\r\n  }\r\n\r\n  absxk = fabs(x[1]);\r\n  if (absxk > scale) {\r\n    t = scale / absxk;\r\n    y = y * t * t + 1.0;\r\n    scale = absxk;\r\n  } else {\r\n    t = absxk / scale;\r\n    y += t * t;\r\n  }\r\n\r\n  absxk = fabs(x[2]);\r\n  if (absxk > scale) {\r\n    t = scale / absxk;\r\n    y = y * t * t + 1.0;\r\n    scale = absxk;\r\n  } else {\r\n    t = absxk / scale;\r\n    y += t * t;\r\n  }\r\n\r\n  absxk = fabs(x[3]);\r\n  if (absxk > scale) {\r\n    t = scale / absxk;\r\n    y = y * t * t + 1.0;\r\n    scale = absxk;\r\n  } else {\r\n    t = absxk / scale;\r\n    y += t * t;\r\n  }\r\n\r\n  return scale * sqrt(y);\r\n}\r\n\r\n/* Model step function */\r\nvoid attitude_determination_and_vehi_step(void)\r\n{\r\n  real_T F[36];\r\n  real_T F_0[36];\r\n  real_T F_1[36];\r\n  real_T P_0[36];\r\n  real_T P_o_tmp_0[36];\r\n  real_T a[36];\r\n  real_T H[18];\r\n  real_T H_0[18];\r\n  real_T K[18];\r\n  real_T P_1[18];\r\n  real_T H_1[9];\r\n  real_T delta_x[6];\r\n  real_T q_n2m[4];\r\n  real_T tmp[4];\r\n  real_T tmp_0[4];\r\n  real_T rtb_hat_omega[3];\r\n  real_T tmp_1[3];\r\n  real_T F_2;\r\n  real_T P_2;\r\n  real_T rtb_q_n2m_idx_0;\r\n  real_T rtb_q_n2m_idx_1;\r\n  real_T rtb_q_n2m_idx_2;\r\n  real_T rtb_q_n2m_idx_3;\r\n  int32_T F_tmp;\r\n  int32_T H_tmp;\r\n  int32_T a_tmp;\r\n  int32_T k;\r\n  int8_T P_o_tmp[36];\r\n  int8_T K_tmp[9];\r\n  static const int8_T b[9] = { 1, 0, 0, 0, 1, 0, 0, 0, 1 };\r\n\r\n  static const int8_T e_a[36] = { -1, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, -1,\r\n    0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1 };\r\n\r\n  /* MATLAB Function: '<S1>/MEKF' incorporates:\r\n   *  Constant: '<S1>/Kalman Filter Timestep'\r\n   *  DataStoreRead: '<S1>/Data Store Read1'\r\n   *  DataStoreRead: '<S1>/Data Store Read2'\r\n   *  DataStoreWrite: '<S1>/Data Store Write'\r\n   *  Inport: '<Root>/earth_mag_field_ref'\r\n   *  Inport: '<Root>/mes_mag'\r\n   *  Inport: '<Root>/mes_ss'\r\n   *  Inport: '<Root>/omega'\r\n   *  Inport: '<Root>/sat_to_sun_unit_ref'\r\n   *  Math: '<S1>/Transpose1'\r\n   */\r\n  rtb_hat_omega[0] = rtU.sat_to_sun_unit_ref[0];\r\n  rtb_hat_omega[1] = rtU.sat_to_sun_unit_ref[1];\r\n  rtb_hat_omega[2] = rtU.sat_to_sun_unit_ref[2];\r\n  quatrotate(rtDW.q_n2m, rtb_hat_omega);\r\n  H[0] = 0.0;\r\n  H[3] = -rtb_hat_omega[2];\r\n  H[6] = rtb_hat_omega[1];\r\n  H[9] = 0.0;\r\n  H[12] = 0.0;\r\n  H[15] = 0.0;\r\n  H[1] = rtb_hat_omega[2];\r\n  H[4] = 0.0;\r\n  H[7] = -rtb_hat_omega[0];\r\n  H[10] = 0.0;\r\n  H[13] = 0.0;\r\n  H[16] = 0.0;\r\n  H[2] = -rtb_hat_omega[1];\r\n  H[5] = rtb_hat_omega[0];\r\n  H[8] = 0.0;\r\n  H[11] = 0.0;\r\n  H[14] = 0.0;\r\n  H[17] = 0.0;\r\n  for (k = 0; k < 3; k++) {\r\n    for (a_tmp = 0; a_tmp < 6; a_tmp++) {\r\n      K[a_tmp + 6 * k] = H[3 * a_tmp + k];\r\n    }\r\n  }\r\n\r\n  for (k = 0; k < 9; k++) {\r\n    K_tmp[k] = b[k];\r\n  }\r\n\r\n  for (k = 0; k < 6; k++) {\r\n    for (a_tmp = 0; a_tmp < 3; a_tmp++) {\r\n      rtb_q_n2m_idx_0 = 0.0;\r\n      for (H_tmp = 0; H_tmp < 6; H_tmp++) {\r\n        rtb_q_n2m_idx_0 += H[3 * H_tmp + a_tmp] * rtDW.P_o[6 * k + H_tmp];\r\n      }\r\n\r\n      H_0[a_tmp + 3 * k] = rtb_q_n2m_idx_0;\r\n    }\r\n  }\r\n\r\n  for (k = 0; k < 3; k++) {\r\n    for (a_tmp = 0; a_tmp < 6; a_tmp++) {\r\n      P_2 = 0.0;\r\n      for (H_tmp = 0; H_tmp < 6; H_tmp++) {\r\n        P_2 += rtDW.P_o[6 * H_tmp + a_tmp] * K[6 * k + H_tmp];\r\n      }\r\n\r\n      P_1[a_tmp + 6 * k] = P_2;\r\n    }\r\n\r\n    for (a_tmp = 0; a_tmp < 3; a_tmp++) {\r\n      P_2 = 0.0;\r\n      for (H_tmp = 0; H_tmp < 6; H_tmp++) {\r\n        P_2 += H_0[3 * H_tmp + k] * K[6 * a_tmp + H_tmp];\r\n      }\r\n\r\n      H_tmp = 3 * a_tmp + k;\r\n      H_1[H_tmp] = (real_T)K_tmp[H_tmp] * 0.0625 + P_2;\r\n    }\r\n  }\r\n\r\n  mrdiv(P_1, H_1, K);\r\n  for (k = 0; k < 3; k++) {\r\n    P_2 = 0.0;\r\n    for (a_tmp = 0; a_tmp < 6; a_tmp++) {\r\n      P_2 += H[3 * a_tmp + k] * 0.0;\r\n    }\r\n\r\n    tmp_1[k] = (rtU.mes_ss[k] - rtb_hat_omega[k]) - P_2;\r\n  }\r\n\r\n  P_2 = tmp_1[1];\r\n  rtb_q_n2m_idx_0 = tmp_1[0];\r\n  rtb_q_n2m_idx_1 = tmp_1[2];\r\n  for (k = 0; k < 6; k++) {\r\n    delta_x[k] = (K[k + 6] * P_2 + K[k] * rtb_q_n2m_idx_0) + K[k + 12] *\r\n      rtb_q_n2m_idx_1;\r\n  }\r\n\r\n  memset(&F[0], 0, 36U * sizeof(real_T));\r\n  for (k = 0; k < 6; k++) {\r\n    F[k + 6 * k] = 1.0;\r\n  }\r\n\r\n  for (k = 0; k < 6; k++) {\r\n    rtb_q_n2m_idx_0 = K[k + 6];\r\n    rtb_q_n2m_idx_1 = K[k];\r\n    rtb_q_n2m_idx_2 = K[k + 12];\r\n    for (a_tmp = 0; a_tmp < 6; a_tmp++) {\r\n      F_tmp = 6 * a_tmp + k;\r\n      F_0[F_tmp] = F[F_tmp] - ((H[3 * a_tmp + 1] * rtb_q_n2m_idx_0 + H[3 * a_tmp]\r\n        * rtb_q_n2m_idx_1) + H[3 * a_tmp + 2] * rtb_q_n2m_idx_2);\r\n    }\r\n\r\n    for (a_tmp = 0; a_tmp < 6; a_tmp++) {\r\n      P_2 = 0.0;\r\n      for (H_tmp = 0; H_tmp < 6; H_tmp++) {\r\n        P_2 += F_0[6 * H_tmp + k] * rtDW.P_o[6 * a_tmp + H_tmp];\r\n      }\r\n\r\n      P_0[k + 6 * a_tmp] = P_2;\r\n    }\r\n  }\r\n\r\n  rtb_hat_omega[0] = rtU.earth_mag_field_ref[0];\r\n  rtb_hat_omega[1] = rtU.earth_mag_field_ref[1];\r\n  rtb_hat_omega[2] = rtU.earth_mag_field_ref[2];\r\n  quatrotate(rtDW.q_n2m, rtb_hat_omega);\r\n  H[0] = 0.0;\r\n  H[3] = -rtb_hat_omega[2];\r\n  H[6] = rtb_hat_omega[1];\r\n  H[9] = 0.0;\r\n  H[12] = 0.0;\r\n  H[15] = 0.0;\r\n  H[1] = rtb_hat_omega[2];\r\n  H[4] = 0.0;\r\n  H[7] = -rtb_hat_omega[0];\r\n  H[10] = 0.0;\r\n  H[13] = 0.0;\r\n  H[16] = 0.0;\r\n  H[2] = -rtb_hat_omega[1];\r\n  H[5] = rtb_hat_omega[0];\r\n  H[8] = 0.0;\r\n  H[11] = 0.0;\r\n  H[14] = 0.0;\r\n  H[17] = 0.0;\r\n  for (k = 0; k < 3; k++) {\r\n    for (a_tmp = 0; a_tmp < 6; a_tmp++) {\r\n      F_tmp = 3 * a_tmp + k;\r\n      K[a_tmp + 6 * k] = H[F_tmp];\r\n      rtb_q_n2m_idx_0 = 0.0;\r\n      for (H_tmp = 0; H_tmp < 6; H_tmp++) {\r\n        rtb_q_n2m_idx_0 += H[3 * H_tmp + k] * P_0[6 * a_tmp + H_tmp];\r\n      }\r\n\r\n      H_0[F_tmp] = rtb_q_n2m_idx_0;\r\n    }\r\n  }\r\n\r\n  for (k = 0; k < 3; k++) {\r\n    for (a_tmp = 0; a_tmp < 6; a_tmp++) {\r\n      P_2 = 0.0;\r\n      for (H_tmp = 0; H_tmp < 6; H_tmp++) {\r\n        P_2 += P_0[6 * H_tmp + a_tmp] * K[6 * k + H_tmp];\r\n      }\r\n\r\n      P_1[a_tmp + 6 * k] = P_2;\r\n    }\r\n\r\n    for (a_tmp = 0; a_tmp < 3; a_tmp++) {\r\n      P_2 = 0.0;\r\n      for (H_tmp = 0; H_tmp < 6; H_tmp++) {\r\n        P_2 += H_0[3 * H_tmp + k] * K[6 * a_tmp + H_tmp];\r\n      }\r\n\r\n      H_tmp = 3 * a_tmp + k;\r\n      H_1[H_tmp] = (real_T)K_tmp[H_tmp] * 0.0625 + P_2;\r\n    }\r\n  }\r\n\r\n  mrdiv(P_1, H_1, K);\r\n  for (k = 0; k < 3; k++) {\r\n    P_2 = 0.0;\r\n    for (a_tmp = 0; a_tmp < 6; a_tmp++) {\r\n      P_2 += H[3 * a_tmp + k] * delta_x[a_tmp];\r\n    }\r\n\r\n    tmp_1[k] = (rtU.mes_mag[k] - rtb_hat_omega[k]) - P_2;\r\n  }\r\n\r\n  P_2 = tmp_1[1];\r\n  rtb_q_n2m_idx_0 = tmp_1[0];\r\n  rtb_q_n2m_idx_1 = tmp_1[2];\r\n  for (k = 0; k < 6; k++) {\r\n    delta_x[k] += (K[k + 6] * P_2 + K[k] * rtb_q_n2m_idx_0) + K[k + 12] *\r\n      rtb_q_n2m_idx_1;\r\n  }\r\n\r\n  memset(&F[0], 0, 36U * sizeof(real_T));\r\n  for (k = 0; k < 6; k++) {\r\n    F[k + 6 * k] = 1.0;\r\n  }\r\n\r\n  for (k = 0; k < 6; k++) {\r\n    rtb_q_n2m_idx_0 = K[k + 6];\r\n    rtb_q_n2m_idx_1 = K[k];\r\n    rtb_q_n2m_idx_2 = K[k + 12];\r\n    for (a_tmp = 0; a_tmp < 6; a_tmp++) {\r\n      F_tmp = 6 * a_tmp + k;\r\n      F_0[F_tmp] = F[F_tmp] - ((H[3 * a_tmp + 1] * rtb_q_n2m_idx_0 + H[3 * a_tmp]\r\n        * rtb_q_n2m_idx_1) + H[3 * a_tmp + 2] * rtb_q_n2m_idx_2);\r\n    }\r\n\r\n    for (a_tmp = 0; a_tmp < 6; a_tmp++) {\r\n      F_2 = 0.0;\r\n      for (H_tmp = 0; H_tmp < 6; H_tmp++) {\r\n        F_2 += F_0[6 * H_tmp + k] * P_0[6 * a_tmp + H_tmp];\r\n      }\r\n\r\n      F_1[k + 6 * a_tmp] = F_2;\r\n    }\r\n  }\r\n\r\n  memcpy(&P_0[0], &F_1[0], 36U * sizeof(real_T));\r\n  tmp[0] = 0.0;\r\n  tmp[1] = delta_x[0];\r\n  tmp[2] = delta_x[1];\r\n  tmp[3] = delta_x[2];\r\n  quatmultiply(rtDW.q_n2m, tmp, tmp_0);\r\n  q_n2m[0] = 0.5 * tmp_0[0] + rtDW.q_n2m[0];\r\n  q_n2m[1] = 0.5 * tmp_0[1] + rtDW.q_n2m[1];\r\n  q_n2m[2] = 0.5 * tmp_0[2] + rtDW.q_n2m[2];\r\n  q_n2m[3] = 0.5 * tmp_0[3] + rtDW.q_n2m[3];\r\n  P_2 = norm(q_n2m);\r\n  q_n2m[0] /= P_2;\r\n  q_n2m[1] /= P_2;\r\n  q_n2m[2] /= P_2;\r\n  q_n2m[3] /= P_2;\r\n  rtb_hat_omega[0] = rtU.omega[0] - rtDW.beta[0];\r\n  rtb_hat_omega[1] = rtU.omega[1] - rtDW.beta[1];\r\n  rtb_hat_omega[2] = rtU.omega[2] - rtDW.beta[2];\r\n  tmp[0] = 0.0;\r\n  tmp[1] = rtb_hat_omega[0];\r\n  tmp[2] = rtb_hat_omega[1];\r\n  tmp[3] = rtb_hat_omega[2];\r\n  quatmultiply(q_n2m, tmp, tmp_0);\r\n  q_n2m[0] += 0.5 * tmp_0[0] * 0.1;\r\n  q_n2m[1] += 0.5 * tmp_0[1] * 0.1;\r\n  q_n2m[2] += 0.5 * tmp_0[2] * 0.1;\r\n  q_n2m[3] += 0.5 * tmp_0[3] * 0.1;\r\n  P_2 = norm(q_n2m);\r\n  rtb_q_n2m_idx_0 = q_n2m[0] / P_2;\r\n  rtb_q_n2m_idx_1 = q_n2m[1] / P_2;\r\n  rtb_q_n2m_idx_2 = q_n2m[2] / P_2;\r\n  rtb_q_n2m_idx_3 = q_n2m[3] / P_2;\r\n  for (k = 0; k < 9; k++) {\r\n    K_tmp[k] = b[k];\r\n  }\r\n\r\n  F[0] = -0.0;\r\n  F[6] = rtb_hat_omega[2];\r\n  F[12] = -rtb_hat_omega[1];\r\n  F[1] = -rtb_hat_omega[2];\r\n  F[7] = -0.0;\r\n  F[13] = rtb_hat_omega[0];\r\n  F[2] = rtb_hat_omega[1];\r\n  F[8] = -rtb_hat_omega[0];\r\n  F[14] = -0.0;\r\n  for (k = 0; k < 3; k++) {\r\n    F_tmp = (k + 3) * 6;\r\n    F[F_tmp] = K_tmp[3 * k];\r\n    F[F_tmp + 1] = K_tmp[3 * k + 1];\r\n    F[F_tmp + 2] = K_tmp[3 * k + 2];\r\n  }\r\n\r\n  for (k = 0; k < 6; k++) {\r\n    F[6 * k + 3] = 0.0;\r\n    F[6 * k + 4] = 0.0;\r\n    F[6 * k + 5] = 0.0;\r\n  }\r\n\r\n  for (k = 0; k < 36; k++) {\r\n    P_o_tmp[k] = e_a[k];\r\n  }\r\n\r\n  for (k = 0; k < 6; k++) {\r\n    for (a_tmp = 0; a_tmp < 6; a_tmp++) {\r\n      F_2 = 0.0;\r\n      P_2 = 0.0;\r\n      for (H_tmp = 0; H_tmp < 6; H_tmp++) {\r\n        F_tmp = 6 * H_tmp + k;\r\n        F_2 += P_0[6 * a_tmp + H_tmp] * F[F_tmp];\r\n        P_2 += F[6 * H_tmp + a_tmp] * P_0[F_tmp];\r\n      }\r\n\r\n      H_tmp = 6 * a_tmp + k;\r\n      F_1[H_tmp] = P_2;\r\n      F_0[H_tmp] = F_2;\r\n    }\r\n  }\r\n\r\n  for (k = 0; k < 3; k++) {\r\n    P_2 = (real_T)K_tmp[3 * k] * 0.0625;\r\n    a[6 * k] = P_2;\r\n    a_tmp = (k + 3) * 6;\r\n    a[a_tmp] = 0.0;\r\n    a[6 * k + 3] = 0.0;\r\n    a[a_tmp + 3] = P_2;\r\n    P_2 = (real_T)K_tmp[3 * k + 1] * 0.0625;\r\n    a[6 * k + 1] = P_2;\r\n    a[a_tmp + 1] = 0.0;\r\n    a[6 * k + 4] = 0.0;\r\n    a[a_tmp + 4] = P_2;\r\n    P_2 = (real_T)K_tmp[3 * k + 2] * 0.0625;\r\n    a[6 * k + 2] = P_2;\r\n    a[a_tmp + 2] = 0.0;\r\n    a[6 * k + 5] = 0.0;\r\n    a[a_tmp + 5] = P_2;\r\n  }\r\n\r\n  for (k = 0; k < 6; k++) {\r\n    for (a_tmp = 0; a_tmp < 6; a_tmp++) {\r\n      P_2 = 0.0;\r\n      for (H_tmp = 0; H_tmp < 6; H_tmp++) {\r\n        P_2 += (real_T)P_o_tmp[6 * H_tmp + k] * a[6 * a_tmp + H_tmp];\r\n      }\r\n\r\n      P_o_tmp_0[k + 6 * a_tmp] = P_2;\r\n    }\r\n\r\n    for (a_tmp = 0; a_tmp < 6; a_tmp++) {\r\n      P_2 = 0.0;\r\n      for (H_tmp = 0; H_tmp < 6; H_tmp++) {\r\n        P_2 += P_o_tmp_0[6 * H_tmp + k] * (real_T)P_o_tmp[6 * a_tmp + H_tmp];\r\n      }\r\n\r\n      F_tmp = 6 * a_tmp + k;\r\n      F[F_tmp] = (F_0[F_tmp] + F_1[F_tmp]) + P_2;\r\n    }\r\n  }\r\n\r\n  for (k = 0; k < 36; k++) {\r\n    rtDW.P_o[k] = F[k] * 0.1 + P_0[k];\r\n  }\r\n\r\n  /* End of MATLAB Function: '<S1>/MEKF' */\r\n\r\n  /* DataStoreWrite: '<S1>/Data Store Write1' */\r\n  rtDW.q_n2m[0] = rtb_q_n2m_idx_0;\r\n  rtDW.q_n2m[1] = rtb_q_n2m_idx_1;\r\n  rtDW.q_n2m[2] = rtb_q_n2m_idx_2;\r\n  rtDW.q_n2m[3] = rtb_q_n2m_idx_3;\r\n\r\n  /* Outport: '<Root>/meas_ang_vel_body' incorporates:\r\n   *  Math: '<S1>/Transpose2'\r\n   */\r\n  rtY.meas_ang_vel_body[0] = rtb_hat_omega[0];\r\n  rtY.meas_ang_vel_body[1] = rtb_hat_omega[1];\r\n  rtY.meas_ang_vel_body[2] = rtb_hat_omega[2];\r\n\r\n  /* Outport: '<Root>/meas_quat_body' */\r\n  rtY.meas_quat_body[0] = rtb_q_n2m_idx_0;\r\n  rtY.meas_quat_body[1] = rtb_q_n2m_idx_1;\r\n  rtY.meas_quat_body[2] = rtb_q_n2m_idx_2;\r\n  rtY.meas_quat_body[3] = rtb_q_n2m_idx_3;\r\n}\r\n\r\n/* Model initialize function */\r\nvoid attitude_determination_and_vehi_initialize(void)\r\n{\r\n  /* Start for DataStoreMemory: '<S1>/Data Store Memory' */\r\n  memcpy(&rtDW.P_o[0], &rtConstP.DataStoreMemory_InitialValue[0], 36U * sizeof\r\n         (real_T));\r\n\r\n  /* Start for DataStoreMemory: '<S1>/Data Store Memory1' */\r\n  rtDW.q_n2m[0] = 1.0;\r\n  rtDW.q_n2m[1] = 0.0;\r\n  rtDW.q_n2m[2] = 0.0;\r\n  rtDW.q_n2m[3] = 0.0;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"attitude_determination_and_vehi.h","type":"header","group":"model","path":"C:\\Users\\joshu\\Desktop\\Orbital\\adcs-modelling\\adcs-modelling\\attitude_determination_and_vehi_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: attitude_determination_and_vehi.h\r\n *\r\n * Code generated for Simulink model 'attitude_determination_and_vehi'.\r\n *\r\n * Model version                  : 3.78\r\n * Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n * C/C++ source code generated on : Mon Jan  1 12:50:14 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-R\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_attitude_determination_and_vehi_h_\r\n#define RTW_HEADER_attitude_determination_and_vehi_h_\r\n#ifndef attitude_determination_and_vehi_COMMON_INCLUDES_\r\n#define attitude_determination_and_vehi_COMMON_INCLUDES_\r\n#include \"rtwtypes.h\"\r\n#include \"rtw_continuous.h\"\r\n#include \"rtw_solver.h\"\r\n#endif                    /* attitude_determination_and_vehi_COMMON_INCLUDES_ */\r\n\r\n/* Macros for accessing real-time model data structure */\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\n/* Forward declaration for rtModel */\r\ntypedef struct tag_RTM RT_MODEL;\r\n\r\n/* Block signals and states (default storage) for system '<Root>' */\r\ntypedef struct {\r\n  real_T P_o[36];                      /* '<S1>/Data Store Memory' */\r\n  real_T q_n2m[4];                     /* '<S1>/Data Store Memory1' */\r\n  real_T beta[3];                      /* '<S1>/Data Store Memory2' */\r\n} DW;\r\n\r\n/* Constant parameters (default storage) */\r\ntypedef struct {\r\n  /* Expression: diag([1*ones(1,3), 1*ones(1,3)])\r\n   * Referenced by: '<S1>/Data Store Memory'\r\n   */\r\n  real_T DataStoreMemory_InitialValue[36];\r\n} ConstP;\r\n\r\n/* External inputs (root inport signals with default storage) */\r\ntypedef struct {\r\n  real_T earth_mag_field_ref[3];       /* '<Root>/earth_mag_field_ref' */\r\n  real_T sat_to_sun_unit_ref[3];       /* '<Root>/sat_to_sun_unit_ref' */\r\n  real_T omega[3];                     /* '<Root>/omega' */\r\n  real_T mes_ss[3];                    /* '<Root>/mes_ss' */\r\n  real_T r_sat_com_ax1[3];             /* '<Root>/r_sat_com' */\r\n  real_T mes_mag[3];                   /* '<Root>/mes_mag' */\r\n  real_T ref_aam[3];                   /* '<Root>/ref_aam' */\r\n  real_T mes_aam[3];                   /* '<Root>/mes_aam' */\r\n  real_T steve_mes[3];                 /* '<Root>/steve_mes' */\r\n} ExtU;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\ntypedef struct {\r\n  real_T meas_ang_vel_body[3];         /* '<Root>/meas_ang_vel_body' */\r\n  real_T meas_quat_body[4];            /* '<Root>/meas_quat_body' */\r\n} ExtY;\r\n\r\n/* Real-time Model Data Structure */\r\nstruct tag_RTM {\r\n  const char_T * volatile errorStatus;\r\n};\r\n\r\n/* Block signals and states (default storage) */\r\nextern DW rtDW;\r\n\r\n/* External inputs (root inport signals with default storage) */\r\nextern ExtU rtU;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\nextern ExtY rtY;\r\n\r\n/* Constant parameters (default storage) */\r\nextern const ConstP rtConstP;\r\n\r\n/* Model entry point functions */\r\nextern void attitude_determination_and_vehi_initialize(void);\r\nextern void attitude_determination_and_vehi_step(void);\r\n\r\n/* Real-time Model object */\r\nextern RT_MODEL *const rtM;\r\n\r\n/*-\r\n * These blocks were eliminated from the model due to optimizations:\r\n *\r\n * Block '<S1>/Estimated Angular Velocity' : Unused code path elimination\r\n * Block '<S1>/Estimated Attitude' : Unused code path elimination\r\n * Block '<S1>/MEKF Covariance Matrix' : Unused code path elimination\r\n * Block '<S1>/Reshape' : Reshape block reduction\r\n * Block '<S1>/Reshape1' : Reshape block reduction\r\n * Block '<S1>/Reshape2' : Reshape block reduction\r\n */\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Note that this particular code originates from a subsystem build,\r\n * and has its own system numbers different from the parent model.\r\n * Refer to the system hierarchy for this subsystem below, and use the\r\n * MATLAB hilite_system command to trace the generated code back\r\n * to the parent model.  For example,\r\n *\r\n * hilite_system('cubesat_alg_dev_env_v2_main/attitude_determination_and_vehicle_est')    - opens subsystem cubesat_alg_dev_env_v2_main/attitude_determination_and_vehicle_est\r\n * hilite_system('cubesat_alg_dev_env_v2_main/attitude_determination_and_vehicle_est/Kp') - opens and selects block Kp\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'cubesat_alg_dev_env_v2_main'\r\n * '<S1>'   : 'cubesat_alg_dev_env_v2_main/attitude_determination_and_vehicle_est'\r\n * '<S2>'   : 'cubesat_alg_dev_env_v2_main/attitude_determination_and_vehicle_est/MEKF'\r\n */\r\n#endif                       /* RTW_HEADER_attitude_determination_and_vehi_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"attitude_determination_and_vehi_data.c","type":"source","group":"data","path":"C:\\Users\\joshu\\Desktop\\Orbital\\adcs-modelling\\adcs-modelling\\attitude_determination_and_vehi_ert_rtw","tag":"","groupDisplay":"Data files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: attitude_determination_and_vehi_data.c\r\n *\r\n * Code generated for Simulink model 'attitude_determination_and_vehi'.\r\n *\r\n * Model version                  : 3.78\r\n * Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n * C/C++ source code generated on : Mon Jan  1 12:50:14 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-R\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"attitude_determination_and_vehi.h\"\r\n\r\n/* Constant parameters (default storage) */\r\nconst ConstP rtConstP = {\r\n  /* Expression: diag([1*ones(1,3), 1*ones(1,3)])\r\n   * Referenced by: '<S1>/Data Store Memory'\r\n   */\r\n  { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 1.0 }\r\n};\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"C:\\Users\\joshu\\Desktop\\Orbital\\adcs-modelling\\adcs-modelling\\attitude_determination_and_vehi_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtwtypes.h\r\n *\r\n * Code generated for Simulink model 'attitude_determination_and_vehi'.\r\n *\r\n * Model version                  : 3.78\r\n * Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n * C/C++ source code generated on : Mon Jan  1 12:50:14 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-R\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n/*=======================================================================*\r\n * Target hardware information\r\n *   Device type: ARM Compatible->ARM Cortex-R\r\n *   Number of bits:     char:   8    short:   16    int:  32\r\n *                       long:  32    long long:  64\r\n *                       native word size:  32\r\n *   Byte ordering: LittleEndian\r\n *   Signed integer division rounds to: Zero\r\n *   Shift right on a signed integer as arithmetic shift: on\r\n *=======================================================================*/\r\n\r\n/*=======================================================================*\r\n * Fixed width word size data types:                                     *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *   real32_T, real64_T           - 32 and 64 bit floating point numbers *\r\n *=======================================================================*/\r\ntypedef signed char int8_T;\r\ntypedef unsigned char uint8_T;\r\ntypedef short int16_T;\r\ntypedef unsigned short uint16_T;\r\ntypedef int int32_T;\r\ntypedef unsigned int uint32_T;\r\ntypedef long long int64_T;\r\ntypedef unsigned long long uint64_T;\r\ntypedef float real32_T;\r\ntypedef double real64_T;\r\n\r\n/*===========================================================================*\r\n * Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\r\n *                           real_T, time_T, ulong_T, ulonglong_T.           *\r\n *===========================================================================*/\r\ntypedef double real_T;\r\ntypedef double time_T;\r\ntypedef unsigned char boolean_T;\r\ntypedef int int_T;\r\ntypedef unsigned int uint_T;\r\ntypedef unsigned long ulong_T;\r\ntypedef unsigned long long ulonglong_T;\r\ntypedef char char_T;\r\ntypedef unsigned char uchar_T;\r\ntypedef char_T byte_T;\r\n\r\n/*=======================================================================*\r\n * Min and Max:                                                          *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *=======================================================================*/\r\n#define MAX_int8_T                     ((int8_T)(127))\r\n#define MIN_int8_T                     ((int8_T)(-128))\r\n#define MAX_uint8_T                    ((uint8_T)(255U))\r\n#define MAX_int16_T                    ((int16_T)(32767))\r\n#define MIN_int16_T                    ((int16_T)(-32768))\r\n#define MAX_uint16_T                   ((uint16_T)(65535U))\r\n#define MAX_int32_T                    ((int32_T)(2147483647))\r\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\r\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\r\n#define MAX_int64_T                    ((int64_T)(9223372036854775807LL))\r\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807LL-1LL))\r\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFULL))\r\n\r\n/* Block D-Work pointer type */\r\ntypedef void * pointer_T;\r\n\r\n#endif                                 /* RTWTYPES_H */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true}};